# 防作弊系统说明

## 概述

为了保证游戏的公平性，系统实现了基于服务端控制的方块序列分配和实时作弊检测机制。所有方块都由服务端生成和分配，客户端无法自行生成或修改方块类型。

## 核心机制

### 1. 服务端方块序列生成

**原理：**
- 游戏开始时，服务端预生成 50 个随机方块
- 每个方块分配唯一 ID（type + timestamp + random）
- 客户端只能使用服务端分配的方块

**实现：**
```javascript
// 服务端生成方块序列
player.pieceSequence = [];
for (let i = 0; i < 50; i++) {
  player.pieceSequence.push(this.generateRandomPiece());
}

// 每个方块有唯一ID
{
  type: 'I',
  id: 'I_1768403775279_abc123',
  color: '#00f0f0',
  shape: [[1,1,1,1]],
  x: 3,
  y: 0
}
```

### 2. 客户端方块请求

**流程：**
1. 游戏开始时，接收前 10 个方块
2. 当前方块锁定后，请求下一个方块
3. 服务端返回 currentPiece 和 nextPiece
4. 客户端严格按照服务端分配的方块进行游戏

**API：**
```javascript
// 开始游戏
POST /api/game/start
Response: {
  gameState: {...},
  pieceSequence: [piece1, piece2, ..., piece10]
}

// 请求下一个方块
POST /api/game/next-piece
Response: {
  currentPiece: {...},
  nextPiece: {...},
  pieceIndex: 5
}
```

### 3. 实时作弊检测

**检测项：**
- ✅ 方块 ID 匹配验证
- ✅ 方块类型匹配验证
- ✅ 方块序列索引验证

**验证逻辑：**
```javascript
validateCurrentPiece(playerId, pieceId, pieceType) {
  const expectedPiece = player.pieceSequence[player.pieceIndex];
  
  // 验证ID
  if (expectedPiece.id !== pieceId) {
    player.cheatingDetected = true;
    return { valid: false, reason: '方块ID不匹配' };
  }
  
  // 验证类型
  if (expectedPiece.type !== pieceType) {
    player.cheatingDetected = true;
    return { valid: false, reason: '方块类型不匹配' };
  }
  
  return { valid: true };
}
```

### 4. 作弊处理机制

**检测到作弊时：**
1. 标记 `player.cheatingDetected = true`
2. 强制结束游戏
3. 不记录分数到历史
4. 通知管理端
5. 向客户端返回错误

**日志记录：**
```
作弊检测: 玩家 张三 (player_xxx) - 方块ID不匹配
  期望: I_1768403775279_abc123
  实际: O_1768403775280_def456
```

## 安全特性

### 1. 方块序列不可预测
- 使用 `Math.random()` 生成随机序列
- 每个游戏的序列都不同
- 客户端无法提前知道未来的方块

### 2. 方块 ID 唯一性
- 包含时间戳和随机字符串
- 几乎不可能伪造或猜测
- 服务端严格验证 ID 匹配

### 3. 实时验证
- 每次游戏状态更新时验证
- 通过 WebSocket 实时推送也会验证
- 多层防护，难以绕过

### 4. 服务端权威
- 所有方块由服务端生成
- 客户端只能请求，不能生成
- 分数计算在客户端，但有服务端验证

## 使用方式

### 玩家端

**正常游戏流程：**
1. 注册并开始游戏
2. 自动接收服务端分配的方块
3. 正常操作游戏
4. 方块锁定时自动请求下一个方块
5. 继续游戏

**无需额外操作** - 所有验证都在后台自动进行

### 管理端

**监控作弊：**
1. 访问后台管理页面
2. 查看玩家列表
3. 如果检测到作弊，会收到通知：
   ```javascript
   {
     type: 'cheatingDetected',
     playerId: 'player_xxx',
     player: {...},
     reason: '方块ID不匹配，疑似作弊'
   }
   ```

## 作弊检测示例

### 场景1：修改方块类型

**攻击：**
客户端尝试将 I 方块改成 O 方块

**检测：**
```
服务端期望: type='I', id='I_xxx'
客户端发送: type='O', id='I_xxx'
结果: ✗ 方块类型不匹配，疑似作弊
```

### 场景2：使用自生成方块

**攻击：**
客户端使用自己生成的方块而不是服务端分配的

**检测：**
```
服务端期望: id='I_1768403775279_abc123'
客户端发送: id='I_1768403775280_xyz789'
结果: ✗ 方块ID不匹配，疑似作弊
```

### 场景3：跳过不喜欢的方块

**攻击：**
客户端尝试跳过当前方块直接使用下一个

**检测：**
```
服务端当前索引: 5
客户端使用方块: pieceSequence[6]
结果: ✗ 方块ID不匹配，疑似作弊
```

## 技术细节

### 方块数据结构

```javascript
{
  type: 'I',                          // 方块类型
  id: 'I_1768403775279_abc123',      // 唯一标识
  color: '#00f0f0',                   // 颜色
  shape: [[1,1,1,1]],                 // 形状
  x: 3,                               // X坐标
  y: 0                                // Y坐标
}
```

### 验证时机

**客户端 → 服务端验证：**
1. 每次游戏状态更新时（POST /api/game/update）
2. 参数 `validatePiece: true` 启用验证
3. 服务端对比当前方块 ID 和类型

**实时推送验证：**
- WebSocket 推送游戏状态时也会验证
- 确保实时同步的数据也是合法的

### 方块序列管理

**服务端：**
```javascript
player.pieceSequence = [...]  // 完整序列（最多70个）
player.pieceIndex = 5         // 当前索引
```

**客户端：**
```javascript
serverPieceSequence = [...]   // 缓存的序列（只有前10个）
currentPieceIndex = 5         // 当前索引
```

## 性能优化

### 1. 预生成方块

- 一次生成 50 个方块
- 避免频繁生成
- 快用完时自动补充

### 2. 部分同步

- 客户端只接收前 10 个方块
- 请求下一个时，如果快用完会自动生成更多
- 减少网络传输

### 3. 异步验证

- 验证不阻塞游戏循环
- 检测到作弊时才中断游戏
- 正常游戏几乎无感

## 局限性

### 当前实现的限制

1. **客户端分数计算** - 分数在客户端计算，理论上可修改
   - 建议：将分数计算移到服务端
   
2. **游戏板状态** - 游戏板状态在客户端维护
   - 建议：服务端也维护游戏板状态并验证

3. **定时器控制** - 下落速度在客户端控制
   - 建议：服务端控制游戏时钟

### 可选增强

如需更强的防护，可以实现：

- [ ] 服务端完整模拟游戏
- [ ] 游戏板状态验证
- [ ] 分数计算服务端化
- [ ] 操作日志记录和回放
- [ ] 异常行为检测（APM）
- [ ] 客户端完整性校验

## 日志和监控

### 服务端日志

**正常日志：**
```
从服务端获取下一个方块: player_xxx, index: 5
```

**作弊日志：**
```
作弊检测: 玩家 张三 (player_xxx) - 方块ID不匹配
  期望: I_1768403775279_abc123
  实际: O_1768403775280_def456
```

### 客户端日志

**正常日志：**
```
接收服务端分配的方块序列: 10 个
从服务端获取下一个方块: success
```

**异常日志：**
```
服务器验证失败: 方块ID不匹配，疑似作弊
检测到异常操作，游戏已终止！
```

## 测试方法

### 正常游戏测试

1. 开始游戏
2. 正常操作方块
3. 观察是否能正常进行
4. 查看服务端日志无错误

### 作弊测试

**修改客户端代码模拟作弊：**
```javascript
// 在 tetris-game.js 中修改
gameState.currentPiece.type = 'O'; // 强制修改类型

// 预期结果：
// - 服务端检测到作弊
// - 游戏强制终止
// - 显示错误提示
```

## 总结

防作弊系统通过以下机制保证游戏公平性：

✅ **服务端控制** - 所有方块由服务端生成
✅ **唯一标识** - 每个方块有唯一 ID
✅ **实时验证** - 每次更新都验证方块合法性
✅ **严格处理** - 检测到作弊立即终止游戏
✅ **日志记录** - 所有作弊行为都有日志

这为公平竞技提供了坚实的技术保障！
